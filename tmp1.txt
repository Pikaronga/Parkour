package com.pikaronga.parkour.storage;

import com.pikaronga.parkour.ParkourPlugin;
import com.pikaronga.parkour.course.Checkpoint;
import com.pikaronga.parkour.course.ParkourCourse;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;

import java.sql.*;
import java.util.*;
import java.util.function.BiConsumer;

public class SqliteParkourStorage {
    private final ParkourPlugin plugin;
    private final DatabaseManager db;
    private final java.util.concurrent.ExecutorService runWriteExecutor;
    private final java.util.concurrent.ConcurrentHashMap<UUID, int[]> statsCache = new java.util.concurrent.ConcurrentHashMap<>();
    private final java.util.concurrent.atomic.AtomicLong globalTotalRuns = new java.util.concurrent.atomic.AtomicLong(0);
    private volatile org.bukkit.scheduler.BukkitTask totalRunsRefreshTask;

    public SqliteParkourStorage(ParkourPlugin plugin, DatabaseManager db) {
        this.plugin = plugin;
        this.db = db;
        this.runWriteExecutor = java.util.concurrent.Executors.newSingleThreadExecutor(r -> {
            Thread t = new Thread(r, "Parkour-RunWrite");
            t.setDaemon(true);
            return t;
        });
    }

    public void shutdown() {
        try {
            runWriteExecutor.shutdown();
            // Wait briefly for queued increments to flush
            runWriteExecutor.awaitTermination(5, java.util.concurrent.TimeUnit.SECONDS);
        } catch (InterruptedException ignored) {
            Thread.currentThread().interrupt();
        } catch (Throwable ignored) {}
        try { if (totalRunsRefreshTask != null) totalRunsRefreshTask.cancel(); } catch (Throwable ignored) {}
    }

    /* =========================================================
     *                        LOAD
     * ========================================================= */
    public List<ParkourCourse> loadCourses() {
        List<ParkourCourse> list = new ArrayList<>();
        String sql = "SELECT * FROM parkours";
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {

            int loaded = 0;
            int skipped = 0;

            while (rs.next()) {
                String name = rs.getString("name");
                String worldName = rs.getString("world");
                World world = worldName != null ? Bukkit.getWorld(worldName) : null;

                if (world == null) {
                    plugin.getLogger().warning("Skipping parkour '" + name + "': world '" + worldName + "' not loaded.");
                    skipped++;
                    continue;
                }

                try {
                    ParkourCourse c = new ParkourCourse(name);

                    ResultSetMetaData md = rs.getMetaData();
                    Set<String> cols = new HashSet<>();
                    for (int ci = 1; ci <= md.getColumnCount(); ci++) {
                        cols.add(md.getColumnName(ci).toLowerCase());
                    }

                    // Teleports
                    c.setStartTeleport(readLocation(world, rs, "start_"));
                    c.setFinishTeleport(readLocation(world, rs, "finish_"));

                    // Plates
                    c.setStartPlate(readBlockLocation(world, rs, "start_plate_"));
                    c.setFinishPlate(readBlockLocation(world, rs, "finish_plate_"));

                    // Difficulty / Published (nullable + guarded)
                    Integer diffObj = getNullableInteger(rs, "difficulty");
                    if (diffObj != null) c.setStaffDifficulty(diffObj);
                    Integer publishedObj = getNullableInteger(rs, "published");
                    c.setPublished(publishedObj != null && publishedObj == 1);

                    // Plot region (optional columns)
                    if (cols.contains("plot_min_x") && cols.contains("plot_min_z") && cols.contains("plot_size")) {
                        Integer minX = getNullableInteger(rs, "plot_min_x");
                        Integer minZ = getNullableInteger(rs, "plot_min_z");
                        Integer size = getNullableInteger(rs, "plot_size");
                        if (minX != null && minZ != null && size != null) {
                            // PlotRegion stores the world name (String) â€” pass world.getName()
                            c.setPlotRegion(new com.pikaronga.parkour.player.PlotRegion(world.getName(), minX, minZ, size));
                        }
                    }

                    // Holograms (optional columns)
                    readHolo(rs, world, cols, c, "top_", c::setTopHologramLocation);
                    readHolo(rs, world, cols, c, "best_", c::setBestHologramLocation);
                    readHolo(rs, world, cols, c, "creator_", c::setCreatorHologramLocation);

                    // Creators, checkpoints, times
                    int id = rs.getInt("id");
                    try { c.setCreatedOrder(id); } catch (Throwable ignored) {}
                    loadCreators(conn, id, c);
                    loadCheckpoints(conn, id, world, c);
                    loadTimes(conn, id, c);
                    // Ratings
                    loadRatings(conn, id, c);
                    // Load run counters (per-player + total)
                    try { loadRunCounts(c); } catch (SQLException e) { plugin.getLogger().warning("Failed to load run counts for '" + name + "': " + e.getMessage()); }

                    list.add(c);
                    loaded++;
                    plugin.getLogger().info("Loaded parkour '" + name + "' in world '" + worldName + "'.");
                } catch (Exception rowEx) {
                    plugin.getLogger().warning("Skipping parkour '" + name + "' due to invalid data: " + rowEx.getMessage());
                }
            }

            plugin.getLogger().info("Course loading summary: " + loaded + " loaded, " + skipped + " skipped.");
        } catch (SQLException e) {
            plugin.getLogger().severe("Failed to load parkours from DB: " + e.getMessage());
        }
        return list;
    }

    /* =========================================================
     *                    RUN COUNTS: LOAD/WRITE
     * ========================================================= */
    public void loadRunCounts(ParkourCourse course) throws SQLException {
        if (course == null) return;
        try (java.sql.Connection conn = db.getConnection()) {
            // Total runs
            try (java.sql.PreparedStatement ps = conn.prepareStatement("SELECT total_runs FROM parkour_run_totals WHERE course=?")) {
                ps.setString(1, course.getName());
                try (java.sql.ResultSet rs = ps.executeQuery()) {
                    if (rs.next()) {
                        course.setTotalRunCount(Math.max(0, rs.getInt(1)));
                    } else {
                        course.setTotalRunCount(0);
                    }
                }
            }
            // Per-player runs
            try (java.sql.PreparedStatement ps = conn.prepareStatement("SELECT player, runs FROM parkour_runs WHERE course=?")) {
                ps.setString(1, course.getName());
                try (java.sql.ResultSet rs = ps.executeQuery()) {
                    while (rs.next()) {
                        try {
                            java.util.UUID u = java.util.UUID.fromString(rs.getString(1));
                            int runs = Math.max(0, rs.getInt(2));
                            course.setPlayerRunCount(u, runs);
                        } catch (IllegalArgumentException ignored) {}
                    }
                }
            }
        }
    }

    public void queueRunIncrement(String courseName, java.util.UUID playerId) {
        if (courseName == null || playerId == null) return;
        runWriteExecutor.submit(() -> saveRunIncrement(courseName, playerId));
    }

    private void saveRunIncrement(String courseName, java.util.UUID playerId) {
        try (java.sql.Connection conn = db.getConnection()) {
            conn.setAutoCommit(false);
            // Per-player upsert
            try (java.sql.PreparedStatement ps = conn.prepareStatement(
                    "INSERT INTO parkour_runs(course, player, runs) VALUES(?,?,1) " +
                            "ON CONFLICT(course, player) DO UPDATE SET runs = runs + 1")) {
                ps.setString(1, courseName);
                ps.setString(2, playerId.toString());
                ps.executeUpdate();
            }
            // Total upsert
            try (java.sql.PreparedStatement ps = conn.prepareStatement(
                    "INSERT INTO parkour_run_totals(course, total_runs) VALUES(?,1) " +
                            "ON CONFLICT(course) DO UPDATE SET total_runs = total_runs + 1")) {
                ps.setString(1, courseName);
                ps.executeUpdate();
            }
            conn.commit();
        } catch (SQLException e) {
            plugin.getLogger().warning("Failed to persist run increment for '" + courseName + "': " + e.getMessage());
        }
    }

    private void readHolo(ResultSet rs, World world, Set<String> cols, ParkourCourse c, String prefix,
                          java.util.function.Consumer<Location> setter) throws SQLException {
        if (cols.contains(prefix + "holo_x")) {
            Double x = getNullableDouble(rs, prefix + "holo_x");
            Double y = getNullableDouble(rs, prefix + "holo_y");
            Double z = getNullableDouble(rs, prefix + "holo_z");
            if (x != null && y != null && z != null) setter.accept(new Location(world, x, y, z));
        }
    }

    private void loadCreators(Connection conn, int parkourId, ParkourCourse c) throws SQLException {
        try (PreparedStatement ps = conn.prepareStatement("SELECT uuid FROM creators WHERE parkour_id=?")) {
            ps.setInt(1, parkourId);
            try (ResultSet crs = ps.executeQuery()) {
                while (crs.next()) {
                    try {
                        c.addCreator(UUID.fromString(crs.getString(1)));
                    } catch (IllegalArgumentException ignored) {}
                }
            }
        }
    }

    private void loadCheckpoints(Connection conn, int parkourId, World world, ParkourCourse c) throws SQLException {
        try (PreparedStatement ps = conn.prepareStatement(
                "SELECT * FROM checkpoints WHERE parkour_id=? ORDER BY ord ASC")) {
            ps.setInt(1, parkourId);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    Double px = getNullableDouble(rs, "plate_x");
                    Double py = getNullableDouble(rs, "plate_y");
                    Double pz = getNullableDouble(rs, "plate_z");
                    Double rx = getNullableDouble(rs, "respawn_x");
                    Double ry = getNullableDouble(rs, "respawn_y");
                    Double rz = getNullableDouble(rs, "respawn_z");
                    Double ryaw = getNullableDouble(rs, "respawn_yaw");
                    Double rpitch = getNullableDouble(rs, "respawn_pitch");
                    if (px == null || py == null || pz == null || rx == null || ry == null || rz == null) continue;
                    float yaw = ryaw == null ? 0f : ryaw.floatValue();
                    float pitch = rpitch == null ? 0f : rpitch.floatValue();
                    c.addCheckpoint(new Checkpoint(new Location(world, px, py, pz),
                            new Location(world, rx, ry, rz, yaw, pitch)));
                }
            }
        }
    }

    public void loadTimes(Connection conn, int parkourId, ParkourCourse c) throws SQLException {
        try (PreparedStatement ps = conn.prepareStatement(
                "SELECT uuid, best_nanos FROM times WHERE parkour_id=?")) {
            ps.setInt(1, parkourId);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    try {
                        UUID u = UUID.fromString(rs.getString(1));
                        long best = rs.getLong(2);
                        c.getTimes().put(u, new ArrayList<>(List.of(best)));
                    } catch (IllegalArgumentException ignored) {}
                }
            }
        }
    }

    private Location readLocation(World world, ResultSet rs, String prefix) throws SQLException {
        Double x = getNullableDouble(rs, prefix + "x");
        Double y = getNullableDouble(rs, prefix + "y");
        Double z = getNullableDouble(rs, prefix + "z");
        Double yawD = getNullableDouble(rs, prefix + "yaw");
        Double pitchD = getNullableDouble(rs, prefix + "pitch");
        if (x == null || y == null || z == null) return null;
        float yaw = yawD == null ? 0f : yawD.floatValue();
        float pitch = pitchD == null ? 0f : pitchD.floatValue();
        return new Location(world, x, y, z, yaw, pitch);
    }

    private Location readBlockLocation(World world, ResultSet rs, String prefix) throws SQLException {
        Double x = getNullableDouble(rs, prefix + "x");
        Double y = getNullableDouble(rs, prefix + "y");
        Double z = getNullableDouble(rs, prefix + "z");
        if (x == null || y == null || z == null) return null;
        return new Location(world, x, y, z);
    }

    private Double getNullableDouble(ResultSet rs, String column) throws SQLException {
        try {
            Object obj = rs.getObject(column);
            if (obj == null) return null;
            if (obj instanceof Number n) return n.doubleValue();
            if (obj instanceof String s) { try { return Double.parseDouble(s); } catch (NumberFormatException ex) { return null; } }
            return null;
        } catch (SQLException ex) { return null; }
    }

    private Integer getNullableInteger(ResultSet rs, String column) throws SQLException {
        try {
            Object obj = rs.getObject(column);
            if (obj == null) return null;
            if (obj instanceof Number n) return n.intValue();
            if (obj instanceof String s) { try { return Integer.parseInt(s); } catch (NumberFormatException ex) { return null; } }
            return null;
        } catch (SQLException ex) { return null; }
    }

    private String resolveWorld(ParkourCourse c) {
        if (c.getStartTeleport() != null && c.getStartTeleport().getWorld() != null)
            return c.getStartTeleport().getWorld().getName();
        if (c.getFinishTeleport() != null && c.getFinishTeleport().getWorld() != null)
            return c.getFinishTeleport().getWorld().getName();
        return plugin.getConfigManager().getPlayerWorldName();
    }

    /* =========================================================
     *                        SAVE
     * ========================================================= */
    public void saveCourses(Map<String, ParkourCourse> courses) {
        try (Connection conn = db.getConnection()) {
            conn.setAutoCommit(false);
            for (ParkourCourse c : courses.values()) {
                int id = upsertCourse(conn, c);
                saveExtras(conn, id, c);

                // Creators (rewrite)
                try (PreparedStatement del = conn.prepareStatement("DELETE FROM creators WHERE parkour_id=?")) {
                    del.setInt(1, id);
                    del.executeUpdate();
                }
                try (PreparedStatement ins = conn.prepareStatement(
